<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `sacn` crate."><meta name="keywords" content="rust, rustlang, rust-lang, sacn"><title>sacn - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../sacn/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate sacn</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all sacn's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'sacn', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/sacn/lib.rs.html#10-222' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>sacn</a></span></h1><div class='docblock'><p>Implementation of the sACN network protocol.</p>
<p>This crate implements the Streaming ACN (sACN) network protocol as specified in ANSI E1.31-2018. Streaming ACN is built on top of and is 
compatible with the ACN protocol suite (ANSI E1.17-2015). This library supports sending and receiving data, universe synchronisation and
universe discovery. This library supports linux (fully) and windows (no receiving multicast) and IP unicast, multicast and broadcast.</p>
<p>Installation instructions are detailed within the README file.</p>
<p>This file was modified as part of a University of St Andrews Computer Science BSC Senior Honours Dissertation Project.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>Creating an sACN receiver and receiving data. This automatically handles receiving synchronised data at the right time with the array of received data
containing all the data which should be acted upon at the same time (so if there are 2 synchronised data packets the array will have length 2).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">sacn</span>::<span class="ident">receive</span>::<span class="ident">SacnReceiver</span>;
<span class="kw">use</span> <span class="ident">sacn</span>::<span class="ident">packet</span>::<span class="ident">ACN_SDT_MULTICAST_PORT</span>;
 
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">net</span>::{<span class="ident">IpAddr</span>, <span class="ident">Ipv4Addr</span>, <span class="ident">SocketAddr</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;
 
<span class="kw">const</span> <span class="ident">UNIVERSE1</span>: <span class="ident">u16</span> <span class="op">=</span> <span class="number">1</span>;
<span class="kw">const</span> <span class="ident">TIMEOUT</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Duration</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">Duration</span>::<span class="ident">from_secs</span>(<span class="number">1</span>)); <span class="comment">// A timeout of None means blocking behaviour, some indicates the actual timeout.</span>
 
<span class="kw">let</span> <span class="ident">addr</span> <span class="op">=</span> <span class="ident">SocketAddr</span>::<span class="ident">new</span>(<span class="ident">IpAddr</span>::<span class="ident">V4</span>(<span class="ident">Ipv4Addr</span>::<span class="ident">LOCALHOST</span>), <span class="ident">ACN_SDT_MULTICAST_PORT</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dmx_rcv</span> <span class="op">=</span> <span class="ident">SacnReceiver</span>::<span class="ident">with_ip</span>(<span class="ident">addr</span>, <span class="prelude-val">None</span>).<span class="ident">unwrap</span>();

<span class="ident">dmx_rcv</span>.<span class="ident">listen_universes</span>(<span class="kw-2">&amp;</span>[<span class="ident">UNIVERSE1</span>]).<span class="ident">unwrap</span>();
 
<span class="comment">// .recv(TIMEOUT) handles processing synchronised as-well as normal data.</span>
<span class="kw">match</span> <span class="ident">dmx_rcv</span>.<span class="ident">recv</span>(<span class="ident">TIMEOUT</span>) {
    <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> {
        <span class="comment">// Print out the error.</span>
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">e</span>);
    }
    <span class="prelude-val">Ok</span>(<span class="ident">p</span>) <span class="op">=</span><span class="op">&gt;</span> {
        <span class="comment">// Print out the data.</span>
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">p</span>);
    }
}</pre></div>
<p>Creating an sACN receiver and checking for discovered sources through universe discovery.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">sacn</span>::<span class="ident">receive</span>::<span class="ident">SacnReceiver</span>;
<span class="kw">use</span> <span class="ident">sacn</span>::<span class="ident">packet</span>::<span class="ident">ACN_SDT_MULTICAST_PORT</span>;
 
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">net</span>::{<span class="ident">IpAddr</span>, <span class="ident">Ipv4Addr</span>, <span class="ident">SocketAddr</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;
 
<span class="kw">const</span> <span class="ident">TIMEOUT</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Duration</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">Duration</span>::<span class="ident">from_secs</span>(<span class="number">1</span>)); <span class="comment">// A timeout of None means blocking behaviour, some indicates the actual timeout.</span>
 
<span class="kw">let</span> <span class="ident">addr</span> <span class="op">=</span> <span class="ident">SocketAddr</span>::<span class="ident">new</span>(<span class="ident">IpAddr</span>::<span class="ident">V4</span>(<span class="ident">Ipv4Addr</span>::<span class="ident">LOCALHOST</span>), <span class="ident">ACN_SDT_MULTICAST_PORT</span>);

<span class="comment">// Creating the receiver, automatically listens for universe discovery packets.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dmx_rcv</span> <span class="op">=</span> <span class="ident">SacnReceiver</span>::<span class="ident">with_ip</span>(<span class="ident">addr</span>, <span class="prelude-val">None</span>).<span class="ident">unwrap</span>();
 
<span class="comment">// Cause source discovery to be announced by a returned error. If this isn&#39;t true then discovery packets are still handled by the user must poll</span>
<span class="comment">// the discovered sources list periodically as there will be no announcement that a discovery packet has been processed. By default this option is</span>
<span class="comment">// off (false) based on the assumption that when receiving data the majority of the time the receiver just wants to process more data from the same</span>
<span class="comment">// universe and doesn&#39;t want to discover sources.</span>
<span class="ident">dmx_rcv</span>.<span class="ident">set_announce_source_discovery</span>(<span class="bool-val">true</span>);
 
<span class="comment">// Receive for a short period, no data is expected but this allows universe discovery packets to be received.</span>
<span class="comment">// This example will always timeout if run in isolation as there are no sources running on the network. </span>
<span class="kw">match</span> <span class="ident">dmx_rcv</span>.<span class="ident">recv</span>(<span class="ident">TIMEOUT</span>) {
    <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="ident">e</span>.<span class="ident">kind</span>() {
            <span class="ident">sacn</span>::<span class="ident">error</span>::<span class="ident">errors</span>::<span class="ident">ErrorKind</span>::<span class="ident">SourceDiscovered</span>(<span class="ident">source_name</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Source name: {} discovered!&quot;</span>, <span class="ident">source_name</span>);    
            }
            <span class="ident">other</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="comment">// Print out the error.</span>
                <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">other</span>);
            }
        }
    }
    <span class="prelude-val">Ok</span>(<span class="ident">p</span>) <span class="op">=</span><span class="op">&gt;</span> {
        <span class="comment">// Print out the data. Note that no data is expected as no universes are registered for receiving data.</span>
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">p</span>);
    }
}</pre></div>
<p>Creating a sACN sender and sending some unsychronised data. An sACNSender automatically sends universe discovery packets.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">sacn</span>::<span class="ident">source</span>::<span class="ident">SacnSource</span>;
<span class="kw">use</span> <span class="ident">sacn</span>::<span class="ident">packet</span>::<span class="ident">ACN_SDT_MULTICAST_PORT</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">net</span>::{<span class="ident">IpAddr</span>, <span class="ident">SocketAddr</span>};

<span class="kw">let</span> <span class="ident">local_addr</span>: <span class="ident">SocketAddr</span> <span class="op">=</span> <span class="ident">SocketAddr</span>::<span class="ident">new</span>(<span class="ident">IpAddr</span>::<span class="ident">V4</span>(<span class="string">&quot;0.0.0.0&quot;</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>()), <span class="ident">ACN_SDT_MULTICAST_PORT</span> <span class="op">+</span> <span class="number">1</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="ident">SacnSource</span>::<span class="ident">with_ip</span>(<span class="string">&quot;Source&quot;</span>, <span class="ident">local_addr</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">universe</span>: <span class="ident">u16</span> <span class="op">=</span> <span class="number">1</span>;                        <span class="comment">// Universe the data is to be sent on.</span>
<span class="kw">let</span> <span class="ident">sync_uni</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;             <span class="comment">// Don&#39;t want the packet to be delayed on the receiver awaiting synchronisation.</span>
<span class="kw">let</span> <span class="ident">priority</span>: <span class="ident">u8</span> <span class="op">=</span> <span class="number">100</span>;                       <span class="comment">// The priority for the sending data, must be 1-200 inclusive,  None means use default.</span>
<span class="kw">let</span> <span class="ident">dst_ip</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">SocketAddr</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;        <span class="comment">// Sending the data using IP multicast so don&#39;t have a destination IP.</span>

<span class="ident">src</span>.<span class="ident">register_universe</span>(<span class="ident">universe</span>).<span class="ident">unwrap</span>(); <span class="comment">// Register with the source that will be sending on the given universe.</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">128</span>, <span class="number">128</span>]; <span class="comment">// Some arbitrary data, must have length &lt;= 513 (including start-code).</span>

<span class="ident">src</span>.<span class="ident">send</span>(<span class="kw-2">&amp;</span>[<span class="ident">universe</span>], <span class="kw-2">&amp;</span><span class="ident">data</span>, <span class="prelude-val">Some</span>(<span class="ident">priority</span>), <span class="ident">dst_ip</span>, <span class="ident">sync_uni</span>).<span class="ident">unwrap</span>(); <span class="comment">// Actually send the data</span>
 </pre></div>
<p>Creating a sACN sender and sending some synchronised data. </p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">sacn</span>::<span class="ident">source</span>::<span class="ident">SacnSource</span>;
<span class="kw">use</span> <span class="ident">sacn</span>::<span class="ident">packet</span>::<span class="ident">ACN_SDT_MULTICAST_PORT</span>;
 
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">net</span>::{<span class="ident">IpAddr</span>, <span class="ident">SocketAddr</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>::<span class="ident">sleep</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;

<span class="kw">let</span> <span class="ident">local_addr</span>: <span class="ident">SocketAddr</span> <span class="op">=</span> <span class="ident">SocketAddr</span>::<span class="ident">new</span>(<span class="ident">IpAddr</span>::<span class="ident">V4</span>(<span class="string">&quot;0.0.0.0&quot;</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>()), <span class="ident">ACN_SDT_MULTICAST_PORT</span> <span class="op">+</span> <span class="number">1</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="ident">SacnSource</span>::<span class="ident">with_ip</span>(<span class="string">&quot;Source&quot;</span>, <span class="ident">local_addr</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">universe</span>: <span class="ident">u16</span> <span class="op">=</span> <span class="number">1</span>;                        <span class="comment">// Universe the data is to be sent on.</span>
<span class="kw">let</span> <span class="ident">sync_uni</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">1</span>);          <span class="comment">// Data packets use a synchronisation address of 1.</span>
<span class="kw">let</span> <span class="ident">priority</span>: <span class="ident">u8</span> <span class="op">=</span> <span class="number">100</span>;                       <span class="comment">// The priority for the sending data, must be 1-200 inclusive,  None means use default.</span>
<span class="kw">let</span> <span class="ident">dst_ip</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">SocketAddr</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;        <span class="comment">// Sending the data using IP multicast so don&#39;t have a destination IP.</span>

<span class="ident">src</span>.<span class="ident">register_universe</span>(<span class="ident">universe</span>).<span class="ident">unwrap</span>(); <span class="comment">// Register with the source that will be sending on the given universe.</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">128</span>, <span class="number">128</span>]; <span class="comment">// Some arbitrary data, must have length &lt;= 513 (including start-code).</span>

<span class="comment">// Actually send the data, since the sync_uni is not 0 the data will be synchronised at the receiver (if the receiver supports synchronisation).</span>
<span class="ident">src</span>.<span class="ident">send</span>(<span class="kw-2">&amp;</span>[<span class="ident">universe</span>], <span class="kw-2">&amp;</span><span class="ident">data</span>, <span class="prelude-val">Some</span>(<span class="ident">priority</span>), <span class="ident">dst_ip</span>, <span class="ident">sync_uni</span>).<span class="ident">unwrap</span>();
 
<span class="comment">// A small delay between sending data and sending the sync packet as recommend in ANSI E1.31-2018 Section 11.2.2.</span>
<span class="ident">sleep</span>(<span class="ident">Duration</span>::<span class="ident">from_millis</span>(<span class="number">10</span>));
 
<span class="comment">// To actually trigger the data need to send a synchronisation packet like so.</span>
<span class="ident">src</span>.<span class="ident">send_sync_packet</span>(<span class="ident">sync_uni</span>.<span class="ident">unwrap</span>(), <span class="ident">dst_ip</span>).<span class="ident">unwrap</span>();</pre></div>
<p>Creating a sACN sender and sending data using unicast.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">sacn</span>::<span class="ident">source</span>::<span class="ident">SacnSource</span>;
<span class="kw">use</span> <span class="ident">sacn</span>::<span class="ident">packet</span>::<span class="ident">ACN_SDT_MULTICAST_PORT</span>;
 
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">net</span>::{<span class="ident">IpAddr</span>, <span class="ident">SocketAddr</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>::<span class="ident">sleep</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">time</span>::<span class="ident">Duration</span>;

<span class="kw">let</span> <span class="ident">local_addr</span>: <span class="ident">SocketAddr</span> <span class="op">=</span> <span class="ident">SocketAddr</span>::<span class="ident">new</span>(<span class="ident">IpAddr</span>::<span class="ident">V4</span>(<span class="string">&quot;0.0.0.0&quot;</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>()), <span class="ident">ACN_SDT_MULTICAST_PORT</span> <span class="op">+</span> <span class="number">1</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="ident">SacnSource</span>::<span class="ident">with_ip</span>(<span class="string">&quot;Source&quot;</span>, <span class="ident">local_addr</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">universe</span>: <span class="ident">u16</span> <span class="op">=</span> <span class="number">1</span>;                        <span class="comment">// Universe the data is to be sent on.</span>
<span class="kw">let</span> <span class="ident">sync_uni</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;             <span class="comment">// Data packets are unsynchronised in this example but unicast transmission supports synchronised and unsynchronised sending.</span>
<span class="kw">let</span> <span class="ident">priority</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">100</span>);                       <span class="comment">// The priority for the sending data, must be 1-200 inclusive,  None means use default.</span>
 
<span class="comment">// To send using unicast the dst_ip argument is set to a Some() value with the address to send the data to. By default the port should be the</span>
<span class="comment">// ACN_SDT_MULTICAST_PORT but this can be configured differently if required in a specific situation. Change this address to the correct address for your</span>
<span class="comment">// application, 192.168.0.1 is just a stand-in.</span>
<span class="kw">let</span> <span class="ident">destination_address</span>: <span class="ident">SocketAddr</span> <span class="op">=</span> <span class="ident">SocketAddr</span>::<span class="ident">new</span>(<span class="ident">IpAddr</span>::<span class="ident">V4</span>(<span class="string">&quot;192.168.0.1&quot;</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>()), <span class="ident">ACN_SDT_MULTICAST_PORT</span>);
<span class="kw">let</span> <span class="ident">dst_ip</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">SocketAddr</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">destination_address</span>);

<span class="ident">src</span>.<span class="ident">register_universe</span>(<span class="ident">universe</span>).<span class="ident">unwrap</span>(); <span class="comment">// Register with the source that will be sending on the given universe.</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">128</span>, <span class="number">128</span>]; <span class="comment">// Some arbitrary data, must have length &lt;= 513 (including start-code).</span>

<span class="comment">// Actually send the data, since the sync_uni is not 0 the data will be synchronised at the receiver (if the receiver supports synchronisation).</span>
<span class="ident">src</span>.<span class="ident">send</span>(<span class="kw-2">&amp;</span>[<span class="ident">universe</span>], <span class="kw-2">&amp;</span><span class="ident">data</span>, <span class="ident">priority</span>, <span class="ident">dst_ip</span>, <span class="ident">sync_uni</span>).<span class="ident">unwrap</span>();</pre></div>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="error/index.html" title='sacn::error mod'>error</a></td><td class='docblock-short'><p>The errors used within the sACN crate, parse/pack errors are seperated out into sacn_parse_pack_error.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="packet/index.html" title='sacn::packet mod'>packet</a></td><td class='docblock-short'><p>The packet module handles the sACN packets including parsing/packing and sACN related constants.
Parsing of sacn network packets.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="receive/index.html" title='sacn::receive mod'>receive</a></td><td class='docblock-short'><p>The receive module handles the receiving of sACN on the network.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="sacn_parse_pack_error/index.html" title='sacn::sacn_parse_pack_error mod'>sacn_parse_pack_error</a></td><td class='docblock-short'><p>The errors within the sACN crate related to parse/pack errors.
Error-chain is used for errors within the library to allow chaining errors together to provide more informative backtraces.
This completely replaces the old error system (sACN crate version 0.4.4) which relied on a simple Enum model without proper backtraces.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="source/index.html" title='sacn::source mod'>source</a></td><td class='docblock-short'><p>The source module handles generation of sACN on the network.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "sacn";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>