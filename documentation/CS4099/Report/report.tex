\documentclass[11pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\author{Paul Lancaster}
\title{Rust Implementation of the ANSI E1.31-2018 sACN Protocol}

\begin{document}
	\input{title-page.tex}
	
	\section{Abstract}
	The project expands on an existing implementation [2] of the streaming architecture for control networks (sACN) protocol [3] in rust with the aim to make a library that is avaliable in rust that allows ANSI E1.31-2018 sACN data transfer, universe synchronisation, universe discovery and that supports Ipv4, Ipv6, Unix and Windows.
	
	\section{Declaration}
	I declare that the material submitted for
	assessment is my own work except where credit is
	explicitly given to others by citation or
	acknowledgement. This work was performed during
	the current academic year except where otherwise
	stated.
	"The main text of this project report is NN,NNN
	words long, including project specification and plan.
	"In submitting this project report to the University of
	St Andrews, I give permission for it to be made
	available for use in accordance with the regulations of the University Library. I also give permission for
	the title and abstract to be published and for copies of the report to be made and supplied at cost to any bonafide library or research worker, and to be made
	available on the World Wide Web. I retain the
	copyright in this work.
	
	
	\tableofcontents
	\pagebreak
	
	\section{Introduction}
		Introduction
		Describe the problem you set out to solve and the
		extent of your success in solving it. You should include
		the aims and objectives of the project in order of
		importance and try to outline key aspects of your
		project for the reader to look for in the rest of your
		report.
	At the time of starting this project there did not exist a native, open-source ANSI E1.31-2018 sACN library for rust which allowed data sending, receiving, universe synchronisation and universe discovery.  The library that did exist was incomplete and only supported sending data and parsing packets.\\
	
	This project therefore aims to create a library for rust users which supports ANSI E1.31-2018 sACN sending, receiving, universe synchronisation and discovery. This project is based on the existing library to give a starting point. As sACN is commonly used in heterogeneous device environments with a mix of embedded systems and operating systems such as Windows and Unix to provide support for as many devices as possible a few additional non-functional requirements were made; The library must have support for both Ipv4 and Ipv6 as well as unicast, multicast and broadcast in both windows and unix environments.\\
	
The project was split into the following list of primary and secondary objectives.\\
	\begin{list}{}{Primary}
		\item Allow sending and receiving DMX data over sACN.
		\item Support the sending and receiving of cross universe DMX data through the 				universe synchronisation feature.
		\item Support universe discovery with adverts for sources and discovery for 					receivers.
	\end{list}
	\begin{list}{}{Secondary}
		\item Demonstrate a deployment of the library into a real-world system to show its compliance with the protocol by showing interoperability with other compliant devices.
		\item Provide support for Windows 10 and Fedora Linux systems.
		\item Support multiple IP transmission modes - Unicast, Multicast and 			Broadcast.
		\item Support multiple IP versions - Ipv4 and Ipv6.
	\end{list}
	
	\section{Context Survey}
	Context survey
	Surveying the context, the background literature and
	any recent work with similar aims. The context survey
	describes the work already done in this area, either as
	described in textbooks, research papers, or in publicly
	available software. You may also describe potentially
	useful tools and technologies here but do not go into
	project-specific decisions.
	
	\subsection{DMX, SACN and ACN}
	\subsubsection{DMX512} DMX512 is an protocol used in the entertainment industry for the control of lighting, effects and other devices. It works by daisy chaining devices together into distinct physical chains (called universes) and is a one way protocol. This means that the devices in the line cannot communicate their presence back to the controller so the controller must know about the devices ahead of time and their addresses so it can broadcast packets down the line which the devices then receive and use. The DMX packets are a fixed size and contain five hundred and twelve 8-byte channel (+ a start code) which allows them to control up to 512 different devices on a singular line. A device may support the use of multiple channels to control different functionalities so for example a light with RGB colour mixing may use 3 channels to allow control of the Red, Green and Blue individually. Since there are only 512 channels available on a single universe this quickly imposes a limitation to the number of devices that can be connected together, especially as modern lighting fixtures commonly use upwards of 30 channels each for a moving light with usage of many more not uncommon. The solution to this was previously to simply have more physical lines (universes) and in this way allow more devices to be controlled simultaneously. This comes with a number of problems however as each new physical line means a new cable coming directly from the control desk.
	
	\paragraph*{DMX512 Problems}
	\begin{list}{}{}
		\item As the control desk is often far from the devices themselves (at the back of the venue whereas the lights/devices are above the stage) it means that many cables need to be run which can be expensive and time consuming.
		\item The length of the cable runs can cause signal interference / degradation and DMX as a 1 way protocol does not have any error correction (bad frames if detected are thrown out).
		\item The protocol only allowing 512 channels per physical line means that a device cannot have more channels than this. This is particularly a problem recently with the advent of complex fixtures which may have many LED's with individual colour control.
	\end{list}
	
	\subsubsection{sACN}
	One solution to solve some of the problems with DMX is to send it using UDP over a standard IP based network and one of the protocols created to do this is sACN. This allows many DMX packets (and so many universes) to be simultaneously sent using a single network cable from the console and then to be received by the devices. Often for backwards compatibility reasons the sACN is converted back into DMX packets before being sent to the device as most devices older than a few years do not support direct sACN communication but this is rapidly increasing - particularly with higher end professional fixtures. 
	
	\subsubsection{sACN - Universe Synchronisation}
	A potential problem with multiplexing multiple universes down a single network line is that two universes of data cannot be sent simultaneously, this is often not a problem but for receiving devices that span multiple universes receiving one packet before the another may put the device into an inconsistent state. A similar problem arises if two different devices on different universes want to be controlled simultaneously. ANSI E1.31-2018 provides a solution to this problem in the form of the universe synchronisation feature. This works by data packets containing a synchronisation universe field which can be set to a specific universe. On receipt of a sACN packet with a non-zero universe synchronisation field a compliant receiver won't act on the packet immediately and instead will hold the data for that universe. This data will then be acted upon on receipt of a universe synchronisation packet with the corresponding universe. As data packets for multiple different universes can specify a single synchronisation universe this allows data for multiple universes to be acted upon simultaneously on receipt of a universe synchronisation packet.
	
	\subsection{Critical Analysis of the sACN protocol}
	ANSI E1.31-2018 sACN over a purely DMX network provides a solution to a number of problems as discussed above but also introduces its own flaws.\\		
	One flaw comes with the concept of universe synchronisation as it relies on all receivers to receive a universe synchronisation packet simultaneously. In real-world networks however this may not be the case and depending on the complexity of the network varying transmission latencies between devices may mean that even with synchronisation multiple sources act on data at different times. Another potential issue with the protocol is that it provides no protection from malicious or malfunctioning sources taking control of the system. This makes isolation, preferably physical, of the network vital and so ANSI E1.31 sACN is commonly used on networks dedicated to lighting protocols. This also helps reduce the issue of variable transmission latencies as these networks are likely to be fairly simple. 
	
	\subsection{Rust}
	Rust \cite{RUST_LANG} is a compiled memory safe language with no garbage collector. It is extremely fast with near C/C++ like performance \cite{RUST_C_COMPARISON} but with a much stricter compiler that guarantees memory safety. As Rust has no runtime due to no garbage collector it is applicable to embedded devices and high performance applications making it an ideal language for an ANSI E1.31-2018 sACN device which are often embedded (e.g. in lighting fixtures) or controlling multiple steams of data in real-time where minimal latency is vitally important (e.g. lighting controllers).
	
	
	
	
	https://www.techrepublic.com/article/rust-programming-language-seven-reasons-why-you-should-learn-it-in-2019/
	
	
	
	Rust \cite{RUST_LANG} is a language designed to be used for writing fast, memory efficient systems code. It has relatively low overhead and because it doesn't require the additional overhead of a garbage collector it is perfect for usage in embedded or high performance systems. 
	
	
	This makes it an ideal language for usage with sACN as responding quickly to control events is vital to a lighting system (imagine a sound effect goes off but the lighting doesn't until a second later). 
	
	\subsection{Related Work}
	The ANSI E1.31 sACN protocol was originally specified in the document ANSI E1.31-2009 \cite{ANSI_E1.31_2009}. This represented the base version of the protocol without any universe synchronisation, universe discovery or discussion of operation with Ipv6. Since then it has been revised in 2016 (universe sync and discovery) \cite{ANSI_E1.31_2016} and again to its current latest version in 2018 (Ipv6). The future of ANSI E1.31 is still being actively developed and discussed \cite{WHAT_COMES_AFTER_SACN} with the direction of the ACN eco-system of lighting control data over IP being focused on supporting communication from receivers back to sources. Within traditional DMX systems this is supported using the remote device management protocol (RDM) as described in ANSI E1.20-2010 \cite{ANSI_E1.20_2010}. An IP version of the RDM protocol was then created (RDMnet) \cite{ANSI_E1.33_2019} which is ACN based and allows discovery and control of receivers over a network. RDMnet as a fairly new protocol is still in the process of being taken up by vendors but has strong support from ETC (a large lighting company \cite{ETC}) in the form of a maintained open source implementation of RDMnet in C++ \cite{ANSI_E1.33_IMPL}.\\
	
	The ACN based family of lighting control protocols aren't the only protocols that allow sending DMX data over an IP network. Another widely adopted protocol is ArtNet which at time of writing is in its 4th version. Unlike sACN on its own ArtNet allows discovery of receivers, remote configuration and transporting RDM data \cite{ARNET} in addition to sending data. ArtNet therefore has taken the strategy of being a larger protocol which covers many use-cases as opposed to the ACN strategy of many protocols each doing a specific area that inter-operate. While they are developed independently the ArtNet v4 standard does allow managing sACN devices which means that it can be used to configure/control sACN devices but with the data still sent over sACN \cite[Pg. 3]{ARTNET}. \\https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust.html]
	
	There are a number of existing implementations of sACN in rust however none are fully compliant with the protocol as specified in ANSI E1.31-2018. One of the most complete is \cite{ORIGNIAL_IMPL} which was used as the base for this project. As this is hosted on github it can be seen that while there are a number of forks (6 at time of writing) no public fork has any further progress which leads to the conclusion that this is the most complete open source rust implementation available. Note that this implementation appears in a number of places such as \cite{ORIGINAL_IMPL_RUST_DOC} but this is still the same implementation.\\
	
	Implementations of sACN exist in multiple languages, at the time of writing (Jan 2020) a cursory search for E1.31 repositories on github reveals repositories in multiple languages with the most prevalent being C++ and C as shown by Figure: \ref{E131_REPO_SEARCH}. An example of one of these projects is \ref{C++_IMPL} which allows both sending and receiving of sACN packets.
	
	\begin{figure}
		\label{E131_REPO_SEARCH}
		\includegraphics[width=\textwidth]{E131-Repo-Search}
		\caption{A search of repositories on github with the search term "E1.31" as of Jan 2020}
	\end{figure}

	\section{Requirement specification}
	Requirements
	specification
	Capturing the properties the software solution must
	have in the form of requirements specification. You
	may wish to specify different types of requirements and
	given them priorities if applicable.
	
	\section{Software Engineering Process}
		Software
	engineering
	process
	The development approach taken and justification for
	its adoption.

	A waterfall based process model was used for the development of the program. In the waterfall
	method there are several distinct phases of the project as shown in figure: \ref{waterfall-diag}. This 
	development approach was chosen as it has a very clear structure which allows easy to manage distinct milestones 
	so progress through the project can be more easily tracked. This process method has a number of disadvantages aswell
	with the main one being the inflexibility - if something major needed to change it would be difficult to adapt the project. 
	As this project is based on a clearly defined specification provided by the protocal specification and the domains were 
	clearly defined at the start it means that this inflexibility isn't a major issue and so therefore choosing the waterfall 
	method for its advantages makes sense. 
	
	\begin{figure}
		\label{waterfall-diag}
		\includegraphics[width=\textwidth]{sdlc_waterfall_model.jpg}
		\caption{A diagram showing the waterfall development process, [\cite{waterfall-diagram}]}
	\end{figure}

	\paragraph*{}
	The waterfall model can be clearly seen throughout the development of the program. The first phase of 'requirement analysis'
	is the protocol specification itself as it clearly lays out the goals of the protocol and what it is required to do. On top of this
	there is the project goals which were defined around the protocol specifically for how much of the protocol this specification should
	implement for example universe-syncronisation, IPv4/IPv6 support, Unix/Windows support etc. When take together this gives a clear list of
	requirements as so allows moving onto the 'system design' phase.

	\paragraph*{}
	The system design phase is where the requirements are turned into a technical plan for how they will be implemented. Alot of this also comes from
	the protocol specification itself as it describes how each bit of a compliant implementation should behave and so therefore the design can be based
	of this.

	\paragraph*{}
	The 'implementation' phase was done 

	One of the requirements
	of the project that was defined was that the implementation should be in rust. This combined with the existing base
	incomplete implementation that was used meant that the general system design was built around this. In general the system
	was designed around there being distinct receivers and senders with communication being mostly one-way. This meant that the two
	different sides could be developed in relative isolation as all their communication must be done in a way that is compliant with the
	protocol which provides the interface between them.

	\paragraph*{}
	The 'testing' phase is the combining of the various bits of the implementation. This is marked by the passing of the various intergration tests
	where the sender and the receiver were passing information back and forth. Also part of this phase is the overall compliance tests which are detailed
	later which show that the implementation of the protocol as a whole conforms to the design and requirements.

	\paragraph*{}
	Once the testing phase has finished the implementation can move onto the 'deployment' phase. In an industry project this would mean 
	distributing the implementation to users and then later moving to the maintenance stage to fix issues or improve various parts of the project
	as opportunities or problems are reported. Within this project the deployment took the form of the development of 2 small programs, one which transmits data 
	specified by the user in the form of various dynamic patterns and a receiver which logs all received input. Theses programs followed a waterfall development
	methodolgy as described later. These programs were then used with various other sACN devices in a real-world environment to show real usage/deployment of
	the protocol. Issues that are discovered at this point can then be fixed through patches which represent the 'maintenance' phase of the program.
	
	\paragraph*{}
	Reflection on the methonolody used
	In general the approach used worked well for the project as it fit the natural development stratergy meaning there weren't any points where the development felt
	like it was 'fighting' the approach chosen. There were a few potential problems that were identified however. One of these was that the model forced rigid time 
	constraints. This is because if too long is spent on any one stage all the subsequent stages would suffer. This was taken as a fairly minor issue for this project 
	because the constraints of fixed submissions deadlines already meant that there some rigid time constraints in place. 

	\ref{waterfall-diagram}
	https://www.tutorialspoint.com/sdlc/sdlc\_waterfall\_model.htm (01/01/2020)
	
	\section*{Ethics}
	This project has no ethical considerations that require notification in this section.
	
	\section{Design}
	Design
	Indicating the structure of the system, with particular
	focus on main ideas of the design, unusual design
	features, etc.
	\subsection{ANSI E1.31-2018}
	\subsection{Critique of the protocol}
	\section{Implementation}
	Implementation
	How the implementation was done and tested, with
	particular focus on important / novel algorithms
	and/or data structures, unusual implementation
	decisions, novel user interface features, etc.
	
	\subsection{Implementation dependent specifics}
	
	\section{Evaluation and Critical Appraisal}
	Evaluation and
	critical
	appraisal
	You should evaluate your own work with respect to
	your original objectives. You should also critically
	evaluate your work with respect to related work done
	by others. You should compare and contrast the project
	to similar work in the public domain, for example as
	written about in published papers, or as distributed in
	software available to you.
	
	\section{Conclusions}
	Conclusions
	You should summarise your project, emphasising your
	key achievements and significant drawbacks to your
	work, and discuss future directions your work could be
	taken in.
	
	\section{Appendices}
	The appendices to your report will normally be as follows.
	Testing
	summary
	This should describe the steps taken to debug, test,
	verify or otherwise confirm the correctness of the
	various modules and their combination.
	
	\section{Testing}
	\subsection{Automated Testing}
	\subsection{Real-world Testing}
	
	\section{User Manual}
	User manual Instructions on installing, executing and using the
	system where appropriate.
	
	\section{Other Appendices}
	Other
	appendices
	If appropriate, you may include other material in
	appendices which are not suitable for inclusion in the
	main body of your report, such as the ethical approval
	document.
	You should not include software listings in your project report, unless it is
	appropriate to discuss small sections in the main body of your report. Instead,
	you will submit via MMS your code and associated material such as JavaDoc
	documentation and detailed UML diagrams
	
	\begin{thebibliography}{9}
		\bibitem{ANSI_E1.17}
		ANSI E1.17 - 2015 Entertainment Technology?Architecture for Control Networks
		\bibitem{ORIGNIAL_IMPL}
		https://github.com/lschmierer/sacn (September 2019)
		\bibitem{ANSI_E1.31}
		ANSI E1.31 ? 2018 Entertainment Technology Lightweight streaming protocol for transport of DMX512 using ACN
		\bibitem{DMX_INFO}
		https://www.element14.com/community/groups/open-source-hardware/blog/2017/08/24/dmx-explained-dmx512-and-rs-485-protocol-detail-for-lighting-applications (17/09/2019)
		\bibitem{C_IMPL}
		https://github.com/hhromic/libe131 (17/09/2019)
		\bibitem{RUST_LANG}
		https://www.rust-lang.org/ (17/09/2019)
		\bibitem{ARTNET}
		http://artisticlicence.com/WebSiteMaster/User\%20Guides/art-net.pdf (17/09/2019)
		\bibitem{ORIGINAL_IMPL_RUST_DOC}
		https://docs.rs/sacn/0.4.4/sacn/index.html
		(26/01/2020)
		\bibitem{C++_IMPL}
		https://github.com/hhromic/libe131
		(26/01/2020)
		\bibitem{ANSI_E1.31_2009}
		https://tsp.esta.org/tsp/documents/docs/E1-31\_2009.pdf
		(26/01/2020)
		\bibitem{ANSI_E1.31_2016}
		https://tsp.esta.org/tsp/documents/docs/E1-31-2016.pdf
		(26/01/2020)
		\bibitem{WHAT_COMES_AFTER_SACN}
		http://www.rdmprotocol.org/files/What\_Comes\_After\_Streaming\_DMX\_over\_ACN\_\%20\%284\%29.pdf (26/01/2020)
		\bibitem{ANSI_E1.33_2019}
		RDM-NET
		\bibitem{ANSI_E1.33_IMPL}
		https://github.com/ETCLabs/RDMnet (26/01/2020)
		\bibitem{ANSI_E1.20_2010}
		RDM
		\bibitem{ETC}
		https://www.etcconnect.com/About/ (26/01/2020)
		\bibitem{RUST_C_COMPARISON}
		https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust.html (28/01/2020)
		
	\end{thebibliography}
	
\end{document}