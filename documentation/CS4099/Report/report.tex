\documentclass[11pt,a4paper,notitlepage]{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\author{160007345}
\title{Rust Implementation of the ANSI E1.31-2018 sACN Protocol}

\setcounter{secnumdepth}{0}

\begin{document}
	\maketitle
	\section{Rough notes}
	Title page
	Containing the title of the project, the names of the
	student(s), "University of St Andrews" and the date of
	submission. You may add the name of your supervisor
	if you wish.
	
	\section{Abstract}
	Abstract Outline of the project using at most 250 words.
	
	The project expands on an existing implementation \cite{ORIGNIAL_IMPL} of the streaming architecture for control networks (sACN) protocol \cite{ANSI_E1.31} in rust with the aim to make a fully compliant library that allows sending and receiving DMX payload data without having to handle E1.31 specifics directly. This library is made to support Ipv4, Ipv6, unix and windows and is tested to show compliance with the protocol.
	
	\section{Declaration}
	Declaration
	"I declare that the material submitted for
	assessment is my own work except where credit is
	explicitly given to others by citation or
	acknowledgement. This work was performed during
	the current academic year except where otherwise
	stated.
	"The main text of this project report is NN,NNN
	words long, including project specification and plan.
	"In submitting this project report to the University of
	St Andrews, I give permission for it to be made
	available for use in accordance with the regulations of the University Library. I also give permission for
	the title and abstract to be published and for copies of the report to be made and supplied at cost to any bonafide library or research worker, and to be made
	available on the World Wide Web. I retain the
	copyright in this work."
	
	If there is a strong case for the protection of
	confidential data, the parts of the declaration giving
	permission for its use and publication may be omitted
	by prior permission of the Honours Coordinator.
	
	\section{Contents Page}
	\tableofcontents
	
	\section{Introduction}
		Introduction
		Describe the problem you set out to solve and the
		extent of your success in solving it. You should include
		the aims and objectives of the project in order of
		importance and try to outline key aspects of your
		project for the reader to look for in the rest of your
		report.
		
	The goal of this project was to create a rust library for sending and receiving sACN data that is fully compliant with the protocol specification as defined in ANSI E1.31-2018 \cite{ANSI_E1.31}. This project is based on an existing but incomplete implementation of the protocol \cite{ORIGNIAL_IMPL} which was then expanded upon.\\
	
	The project was split into the following list of primary and secondary objectives.\\
	\begin{list}{}{Primary}
		\item Learn rust - This is an inherent part of the project as rust is a new language.
		\item Establish the extends of the existing implementation - Only some parts of the protocol had been implemented so need to establish which bits and to what extent.
		\item Introduce more through testing of existing - There is only a small amount of testing for the existing implementation which needs to be expanded on to verify it works
		\item Allow receiving DMX through sACN
		\item Allow sending DMX using universe synchronisation - This involves both data packets and sync packets.
		\item Allow universe discovery - Sources of data can be discovered using adverts.
		\item Add support for the options field - This includes things such as termination of streams and forced synchronisation.
	\end{list}
	\begin{list}{}{Secondary}
		\item Analyse the performance of the protocol implementation verses other implementations in other languages - Using metrics such as data throughput, performance as number of universes increases.
		\item Analyse the performance of the protocol versus other similar protocols such as ArtNet \cite{ArtNet}
		\item Test the implementation in a real-world environment with real devices - Involves creating a small demo program.
		\item Windows and Unix support - Windows 10 and the lab machine Fedora version.
		\item Unicast, Multicast and Broadcast Support - The protocol works over all these with multicast being the preferred.
		\item Ipv4 and Ipv6 support
	\end{list}
	
	
	\section{Context Survey}
	Context survey
	Surveying the context, the background literature and
	any recent work with similar aims. The context survey
	describes the work already done in this area, either as
	described in textbooks, research papers, or in publicly
	available software. You may also describe potentially
	useful tools and technologies here but do not go into
	project-specific decisions.
	
	The ANSI E1.31 sACN protocol was originally specified in the document ANSI E1.31-2009 \cite{ANSI_E1.31_2009}. This represented the base version of the protocol without any universe synchronisation, universe discovery or discussion of operation with Ipv6. Since then it has been revised in 2016 (universe sync and discovery) \cite{ANSI_E1.31_2016} and again to its current latest version in 2018 (Ipv6). The future of ANSI E1.31 is still being actively developed and discussed \cite{WHAT_COMES_AFTER_SACN} with the direction of the ACN eco-system of lighting control data over IP being focused on supporting communication from receivers back to sources. This is 
	
	
	
	 isn't the only protocol built for sending DMX data across a network. 
	
	There are a number of existing implementations of sACN in rust however none are fully compliant with the protocol as specified in ANSI E1.31-2018. One of the most complete is \cite{ORIGNIAL_IMPL} which was used as the base for this project. As this is hosted on github it can be seen that while there are a number of forks (6 at time of writing) no public fork has any further progress which leads to the conclusion that this is the most complete open source rust implementation available. Note that this implementation appears in a number of places such as \cite{ORIGINAL_IMPL_RUST_DOC} but this is still the same implementation.\\
	
	Implementations of sACN exist in multiple languages, at the time of writing (Jan 2020) a cursory search for E1.31 repositories on github reveals repositories in multiple languages with the most prevalent being C++ and C as shown by Figure: \ref{E131_REPO_SEARCH}. An example of one of these projects is \ref{C++_IMPL} which allows both sending and receiving of sACN packets.
	
	\begin{figure}
		\label{E131_REPO_SEARCH}
		\includegraphics[width=\textwidth]{E131-Repo-Search}
		\caption{A search of repositories on github with the search term "E1.31" as of Jan 2020}
	\end{figure}
	
	There exist multiple implementations of the sACN protocol in a 
	
	
	\subsection{DMX, SACN and ACN}
	\subsubsection*{DMX512} DMX512 is an protocol used in the entertainment industry for the control of lighting, effects and other devices. It works by daisy chaining devices together into distinct physical chains (called universes) and is a one way protocol. This means that the devices in the line cannot communicate their presence back to the controller so the controller must know about the devices ahead of time and their addresses so it can broadcast packets down the line which the devices then receive and use. The DMX packets are a fixed size and contain five hundred and twelve 8-byte channel (+ a start code) which allows them to control up to 512 different devices on a singular line. A device may support the use of multiple channels to control different functionalities so for example a light with RGB colour mixing may use 3 channels to allow control of the Red, Green and Blue individually. Since there are only 512 channels available on a single universe this quickly imposes a limitation to the number of devices that can be connected together, especially as modern lighting fixtures commonly use upwards of 30 channels each for a moving light with usage of many more not uncommon. The solution to this was previously to simply have more physical lines (universes) and in this way allow more devices to be controlled simultaneously. This comes with a number of problems however as each new physical line means a new cable coming directly from the control desk.
	
	\paragraph*{DMX512 Problems}
	\begin{list}{}{}
		\item As the control desk is often far from the devices themselves (at the back of the venue whereas the lights/devices are above the stage) it means that many cables need to be run which can be expensive and time consuming.
		\item The length of the cable runs can cause signal interference / degradation and DMX as a 1 way protocol does not have any error correction (bad frames if detected are thrown out).
		\item The protocol only allowing 512 channels per physical line means that a device cannot have more channels than this. This is particularly a problem recently with the advent of complex fixtures which may have many LED's with individual colour control.
	\end{list}
	
	\subsubsection*{sACN}
	One solution to solve some of the problems with DMX is to send it using UDP over a standard IP based network and one of the protocols created to do this is sACN. This allows many DMX packets (and so many universes) to be simultaneously sent using a single network cable from the console and then to be received by the devices. Often for backwards compatibility reasons the sACN is converted back into DMX packets before being sent to the device as most devices older than a few years do not support direct sACN communication but this is rapidly increasing - particularly with higher end professional fixtures. 
	
	\subsubsection*{Rust}
	Rust \cite{RUST_LANG} is a language designed to be used for writing fast, memory efficient systems code. It has relatively low overhead and because it doesn't require the additional overhead of a garbage collector it is perfect for usage in embedded or high performance systems. This makes it an ideal language for usage with sACN as responding quickly to control events is vital to a lighting system (imagine a sound effect goes off but the lighting doesn't until a second later). 
	
	\subsection{Other protocols}
	
	\section{Requirement specification}
	Requirements
	specification
	Capturing the properties the software solution must
	have in the form of requirements specification. You
	may wish to specify different types of requirements and
	given them priorities if applicable.
	
	\section{Software Engineering Process}
		Software
	engineering
	process
	The development approach taken and justification for
	its adoption.

	A waterfall based process model was used for the development of the program. In the waterfall
	method there are several distinct phases of the project as shown in figure: \ref{waterfall-diag}. This 
	development approach was chosen as it has a very clear structure which allows easy to manage distinct milestones 
	so progress through the project can be more easily tracked. This process method has a number of disadvantages aswell
	with the main one being the inflexibility - if something major needed to change it would be difficult to adapt the project. 
	As this project is based on a clearly defined specification provided by the protocal specification and the domains were 
	clearly defined at the start it means that this inflexibility isn't a major issue and so therefore choosing the waterfall 
	method for its advantages makes sense. 
	
	\begin{figure}
		\label{waterfall-diag}
		\includegraphics[width=\textwidth]{sdlc_waterfall_model.jpg}
		\caption{A diagram showing the waterfall development process, [\cite{waterfall-diagram}]}
	\end{figure}

	\paragraph*{}
	The waterfall model can be clearly seen throughout the development of the program. The first phase of 'requirement analysis'
	is the protocol specification itself as it clearly lays out the goals of the protocol and what it is required to do. On top of this
	there is the project goals which were defined around the protocol specifically for how much of the protocol this specification should
	implement for example universe-syncronisation, IPv4/IPv6 support, Unix/Windows support etc. When take together this gives a clear list of
	requirements as so allows moving onto the 'system design' phase.

	\paragraph*{}
	The system design phase is where the requirements are turned into a technical plan for how they will be implemented. Alot of this also comes from
	the protocol specification itself as it describes how each bit of a compliant implementation should behave and so therefore the design can be based
	of this.

	\paragraph*{}
	The 'implementation' phase was done 

	One of the requirements
	of the project that was defined was that the implementation should be in rust. This combined with the existing base
	incomplete implementation that was used meant that the general system design was built around this. In general the system
	was designed around there being distinct receivers and senders with communication being mostly one-way. This meant that the two
	different sides could be developed in relative isolation as all their communication must be done in a way that is compliant with the
	protocol which provides the interface between them.

	\paragraph*{}
	The 'testing' phase is the combining of the various bits of the implementation. This is marked by the passing of the various intergration tests
	where the sender and the receiver were passing information back and forth. Also part of this phase is the overall compliance tests which are detailed
	later which show that the implementation of the protocol as a whole conforms to the design and requirements.

	\paragraph*{}
	Once the testing phase has finished the implementation can move onto the 'deployment' phase. In an industry project this would mean 
	distributing the implementation to users and then later moving to the maintenance stage to fix issues or improve various parts of the project
	as opportunities or problems are reported. Within this project the deployment took the form of the development of 2 small programs, one which transmits data 
	specified by the user in the form of various dynamic patterns and a receiver which logs all received input. Theses programs followed a waterfall development
	methodolgy as described later. These programs were then used with various other sACN devices in a real-world environment to show real usage/deployment of
	the protocol. Issues that are discovered at this point can then be fixed through patches which represent the 'maintenance' phase of the program.
	
	\paragraph*{}
	Reflection on the methonolody used
	In general the approach used worked well for the project as it fit the natural development stratergy meaning there weren't any points where the development felt
	like it was 'fighting' the approach chosen. There were a few potential problems that were identified however. One of these was that the model forced rigid time 
	constraints. This is because if too long is spent on any one stage all the subsequent stages would suffer. This was taken as a fairly minor issue for this project 
	because the constraints of fixed submissions deadlines already meant that there some rigid time constraints in place. 

	\ref{waterfall-diagram}
	https://www.tutorialspoint.com/sdlc/sdlc\_waterfall\_model.htm (01/01/2020)
	
	\section*{Ethics}
	This project has no ethical considerations that require notification in this section.
	
	\section{Design}
	Design
	Indicating the structure of the system, with particular
	focus on main ideas of the design, unusual design
	features, etc.
	\subsection{ANSI E1.31-2018}
	\subsection{Critique of the protocol}
	\section{Implementation}
	Implementation
	How the implementation was done and tested, with
	particular focus on important / novel algorithms
	and/or data structures, unusual implementation
	decisions, novel user interface features, etc.
	
	\subsection{Implementation dependent specifics}
	
	\section{Evaluation and Critical Appraisal}
	Evaluation and
	critical
	appraisal
	You should evaluate your own work with respect to
	your original objectives. You should also critically
	evaluate your work with respect to related work done
	by others. You should compare and contrast the project
	to similar work in the public domain, for example as
	written about in published papers, or as distributed in
	software available to you.
	
	\section{Conclusions}
	Conclusions
	You should summarise your project, emphasising your
	key achievements and significant drawbacks to your
	work, and discuss future directions your work could be
	taken in.
	
	\section{Appendices}
	The appendices to your report will normally be as follows.
	Testing
	summary
	This should describe the steps taken to debug, test,
	verify or otherwise confirm the correctness of the
	various modules and their combination.
	
	\section{Testing}
	\subsection{Automated Testing}
	\subsection{Real-world Testing}
	
	\section{User Manual}
	User manual Instructions on installing, executing and using the
	system where appropriate.
	
	\section{Other Appendices}
	Other
	appendices
	If appropriate, you may include other material in
	appendices which are not suitable for inclusion in the
	main body of your report, such as the ethical approval
	document.
	You should not include software listings in your project report, unless it is
	appropriate to discuss small sections in the main body of your report. Instead,
	you will submit via MMS your code and associated material such as JavaDoc
	documentation and detailed UML diagrams
	
	\begin{thebibliography}{9}
		\bibitem{ANSI_E1.17}
		ANSI E1.17 - 2015 Entertainment Technology?Architecture for Control Networks
		\bibitem{ORIGNIAL_IMPL}
		https://github.com/lschmierer/sacn (September 2019)
		\bibitem{ANSI_E1.31}
		ANSI E1.31 ? 2018 Entertainment Technology Lightweight streaming protocol for transport of DMX512 using ACN
		\bibitem{DMX_INFO}
		https://www.element14.com/community/groups/open-source-hardware/blog/2017/08/24/dmx-explained-dmx512-and-rs-485-protocol-detail-for-lighting-applications (17/09/2019)
		\bibitem{C_IMPL}
		https://github.com/hhromic/libe131 (17/09/2019)
		\bibitem{RUST_LANG}
		https://www.rust-lang.org/ (17/09/2019)
		\bibitem{ArtNet}
		http://artisticlicence.com/WebSiteMaster/User\%20Guides/art-net.pdf (17/09/2019)
		\bibitem{ORIGINAL_IMPL_RUST_DOC}
		https://docs.rs/sacn/0.4.4/sacn/index.html
		(26/01/2020)
		\bibitem{C++_IMPL}
		https://github.com/hhromic/libe131
		(26/01/2020)
		\bibitem{ANSI_E1.31_2009}
		https://tsp.esta.org/tsp/documents/docs/E1-31\_2009.pdf
		(26/01/2020)
		\bibitem{ANSI_E1.31_2016}
		https://tsp.esta.org/tsp/documents/docs/E1-31-2016.pdf
		(26/01/2020)
		\bibitem{WHAT_COMES_AFTER_SACN}
		http://www.rdmprotocol.org/files/What\_Comes\_After\_Streaming\_DMX\_over\_ACN\_\%20\%284\%29.pdf (26/01/2020)
		\bibitem{ANSI_E1.33_2019}
		
		\bibitem{ANSI_E1.33_IMPL}
		https://github.com/ETCLabs/RDMnet (26/01/2020)
		
	\end{thebibliography}
	
\end{document}